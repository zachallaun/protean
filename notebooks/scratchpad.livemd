# Scratchpad

## TODOs

* [x] Parse machine config into state node / transition representation
* [x] keep ID map for all state nodes in machine
* [x] know what state nodes are active for the current state configuration
* [x] basic transitions, start with innermost children and transition if they or ancestor responds to event
* [x] ensure transitions to compound nodes automatically enter the initial node
* [x] implement config/parsing/data model for parallel states
* [ ] transitions to parallel states
* [ ] edge cases for parallel states - how to handle when one parallel child wants to exit entire parallel state but other wants to transition within itself?
* [ ] handle transition precedence based on specificity/order/etc.
* [ ] conditional transitions
* [ ] automatic transitions
* [ ] action execution

## Machine Config

```elixir
alias Protean.{Machine}
```

Defining the state machine in terms of state nodes and transitions.

I think the internal types for these should be relatively rigid and normalized by a transformation step that can occur to get from machine config to these types.

```elixir
machine =
  Machine.new(
    initial: :state_a,
    states: [
      state_a: [
        on: [
          "event.b": :state_b,
          "event.b2": :"state_b.state_b2"
        ]
      ],
      state_b: [
        initial: :state_b1,
        states: [
          state_b1: [
            on: [
              "event.b2": :state_b2
            ]
          ],
          state_b2: [
            on: [
              "event.c": :"#state_c"
            ]
          ]
        ]
      ],
      state_c: [
        type: :final
      ]
    ]
  )
```

```elixir
Map.keys(machine.idmap)
```

## Actions

My early sketches for Protean assumed that actions would be handled by "Handler" modules that could just pattern match on strings, e.g. `def handle_action("some_action_name", context, event)`. This isn't enough though: we need actions to be mapped to some kind of data type that allows the interpreter to infer whether it can be executed/resolved without side effects (like `assign`, `pure`, `send`, etc.) or whether it needs to be executed later.

The question then becomes: how do we specify these sorts of action types in an Elixir-idiomatic way? (Since having a bunch of anonymous functions is kinda gnarly in Elixir).

```elixir
defmodule MyMachine do
  use Protean,
    machine: [
      initial: :foo,
      context: %{
        places_ive_been: []
      },
      states: [
        foo: [
          enter: "add_to_places_ive_been",
          on: [
            goto_bar: :bar
          ]
        ],
        bar: [
          enter: ["add_to_places_ive_been", "log_places_ive_been"],
          type: :final
        ]
      ]
    ]

  @protean :assign
  def handle_action("add_to_places_ive_been", context, _event, %{state: s}) do
    update_in(context.places_ive_been, &[s.value | &1])
  end

  @protean :effect
  def handle_action("log_places_ive_been", %{places_ive_been: places}, _event) do
    IO.inspect(places, label: "Places I've been")
  end
end
```

```elixir
defmodule MyMachine do
  use Protean,
    machine: [
      initial: :foo,
      context: %{
        places_ive_been: []
      },
      states: [
        foo: [
          enter: "add_to_places_ive_been",
          on: [
            goto_bar: :bar
          ]
        ],
        bar: [
          enter: ["add_to_places_ive_been", "log_places_ive_been"],
          type: :final
        ]
      ]
    ],
    actions: [
      add_to_places_ive_been:
        Protean.Actions.assign(fn context, _event, %{state: s} ->
          update_in(context.places_ive_been, &[s.value | &1])
        end),
      log_places_ive_been: fn context, _event ->
        IO.inspect(places, label: "Places I've been")
      end
    ]
end
```

```elixir
defmodule MyMachine do
  use Protean,
    machine: [
      initial: :foo,
      context: %{
        places_ive_been: []
      },
      states: [
        foo: [
          enter: "add_to_places_ive_been",
          on: [
            goto_bar: :bar
          ]
        ],
        bar: [
          enter: ["add_to_places_ive_been", "log_places_ive_been"],
          type: :final
        ]
      ]
    ]

  @impl Protean
  def pure("add_to_places_ive_been", context, _event, %{state: s}) do
    update_in(context.places_ive_been, &[s.value | &1])
  end

  @impl Protean
  def effect("log_places_ive_been", %{places_ive_been: places}, _event, _meta) do
    IO.inspect(places, label: "Places I've been")
  end
end
```

^ This seems pretty promising. Basically each action is broken down into two major handler types, `pure` and `effect`. Default catch-all implementations can be defined for both. `Machine.transition` can basically call all the `pure` handlers, and the interpreter could then call all the `effect` handlers.

With different return "shapes", `pure` could be a catch-all action creator/context assigner. For instance:

```elixir
defmodule MyMachine do
  use Protean,
    machine: [
      # ...
    ]

  alias Protean.Action

  @impl Action
  def pure("assign some stuff", context, {_, data}, _meta) do
    update_in(context.some_list, &[data.value | &1])
  end

  @impl Action
  def pure("same as above", context, {_, data}, _meta) do
    context = update_in(context.some_list, &[data.value | &1])
    # or {context, []}
    {context, nil}
  end

  @impl Action
  def pure("assign and send", context, {_, data}, _meta) do
    context = update_in(context.some_list, &[data.value | &1])
    {context, Action.send("some_event")}
  end

  @impl Action
  def pure("assign and send more", context, {_, data}, _meta) do
    context = update_in(context.some_list, &[data.value | &1])
    {context, [Action.send("some_event"), Action.send(context.some_ref, "some_event")]}
  end

  @impl Action
  def pure("getting crazy", context, _event, _meta) do
    {context, ["some effectful action"]}
  end

  @impl Action
  def effect("some effectful action", _context, _event, _meta) do
    IO.puts("Woo!")
  end
end
```

```elixir
def Protean.Action do
  alias __MODULE__
  alias Protean.{Context, Event}

  @type t :: %Action{}

  @type action_name :: String.t()

  @type unresolved :: action_name | function | Action.t()

  @type pure_value ::
          nil
          # assign new context
          | Context.t()
          # same
          | {Context.t(), nil}
          # assign new context and inject action
          | {Context.t(), Action.unresolved()}
          # same
          | {Context.t(), [Action.unresolved()]}

  @callback pure(action_name, Context.t(), Event.t(), Protean.metadata()) :: pure_value
end
```

This is seeming pretty good. There can be a number of `Action` creators as well in case people want to use them in the way they do in XState.

<!-- livebook:{"force_markdown":true} -->

```elixir
Action.pure(fn -> ... end)
Action.send("event")
Action.send({"event", "event data"})
Action.send(pid, "event")
Action.send_parent("event")
Action.assign(foo: Action.spawn_link(SomeOtherMachine))
# etc.
```

```elixir
defmodule Protean do
  defmodule Unimplemented, do: defstruct([])
end

defmodule Protean.Action do
  alias __MODULE__
  alias Protean.{Machine, Context, State, Event, Unimplemented}

  # This might all belong in the interpreter because it needs to define various
  # actions like spawning new machines, etc.
  defprotocol Executable do
    @spec exec(executable, Context.t(), Event.t(), Protean.metadata()) :: :ok
    def exec(executable, context, event, metadata)
  end

  defimpl Executable, for: Function do
    def exec(fun, context, event, metadata) do
      fun.(context, event, metadata)
      :ok
    end
  end

  defimpl Executable, for(Action) do
    def exec(action, _context, _event, _metadata) do
      %Action{
        handler: module,
        name: name,
        context: context,
        metadata: metadata
      } = action

      apply(module, :effect, [name, context, metadata.event, metadata])

      :ok
    end
  end

  # ...maybe?
  @typedoc "Resolved actions implement the `Executable` protocol"
  @type resolved :: any

  @doc """
  Resolves the actions associated with a state to a new state and a list of
  side-effecting actions that can be executed by an interpreter.
  """
  @spec resolve_actions(State.t(), Module.t()) :: {State.t(), [Action.resolved()]}
  def resolve_actions(%State{} = state, handler) do
    %State{
      value: value,
      context: context,
      actions: actions,
      event: event
    } = state

    metadata = %{state: %{value: value, event: event}}

    resolve_actions(actions, context, handler, meta)
  end

  defp resolve_actions([action | rest], context, handler, meta) do
    {context, r1} = resolve_action(action, context, handler, meta)
    {context, r2} = resolve_actions(rest, context, handler, meta)
    {context, r1 ++ r2}
  end

  defp resolve_actions([], context, _handler, _meta),
    do: {context, []}

  @spec resolve_action(Action.unresolved(), Context.t(), Module.t(), Protean.metadata()) ::
          {Context.t(), [Action.resolved()]}
  defp resolve_action(action, context, handler, meta)

  defp resolve_action(action, context, handler, meta) when is_binary(action) do
    {context, resolved} = resolve_pure(action, context, handler, meta)

    action = %Action{
      handler: handler,
      name: name,
      context: context,
      metadata: meta
    }

    {state, [action | resolved]}
  end

  defp resolve_pure(action_name, context, handler, meta) do
    args = [action_name, context, meta.event, meta]

    handler
    |> apply(:pure, args)
    |> resolve_pure_value(context, handler, meta)
  end

  # Normalizes the return value of the call to `handler.pure/4`
  defp resolve_pure_value(value, context, handler, meta)

  defp resolve_pure_value(nil, context, _handler, _meta),
    do: {context, []}

  defp resolve_pure_value(%{} = new_context, _context, _handler, _meta),
    do: {new_context, []}

  defp resolve_pure_value({new_context, nil}, _context, _handler, _meta),
    do: {new_context, []}

  defp resolve_pure_value({new_context, unresolved}, context, handler, meta)
       when not is_list(unresolved),
       do: resolve_pure_value({new_context, [unresolved]}, context, handler, meta)

  defp resolve_pure_value({new_context, unresolved}, _context, handler, meta)
       when is_list(unresolved),
       do: resolve_actions(unresolved, new_context, handler, meta)
end
```
