# Machine definition syntax

## To macro or not to macro

That is the question!

Right now, Protean machines are defined using Elixir data structures: keyword lists. There's not much magic to machine definition. We assume you have a `@machine` module attribute that defines a machine config, but it's all just data. You don't even need to use the module attribute -- you can  `def machine` or pass it with `use Protean, machine: ...`.

The primary downside to this is that it can be a bit difficult to read/scan. It's easy to get visually lost as to the level of nesting you're at (for nested machines) and `mix format` removes any extra whitespace/etc. you may have put between states to differentiate. It's also easy for different semantic sections of the config to look alike. In order to use the nicer keyword syntax, everything has to be an atom (state names, etc.) even if it's converted internally to a string. It's easy for the `on:` list of events to get visually mixed up with `states:` etc.

I've been hesitant to reach for macros because they introduce complexity and are another thing you have to learn to use the library, but I am now wondering whether the benefits of fuller use of Elixir's syntax would make up for the drawbacks.

## Form Input Example

This is based on [this machine](https://stately.ai/viz/id1) from the Stately visualizer.

<!-- livebook:{"break_markdown":true} -->

#### Data definition

```elixir
defmodule FormInput do
  use Protean

  @machine [
    initial: "Active",
    context: [
      value: ""
    ],
    states: [
      Active: [
        type: "parallel",
        on: [
          DISABLE: "Disabled"
        ],
        states: [
          Focus: [
            initial: "Unfocused",
            states: [
              Focused: [
                on: [
                  BLUR: "Unfocused"
                ]
              ],
              Unfocused: [
                on: [
                  FOCUS: "Focused"
                ]
              ]
            ]
          ],
          Validation: [
            initial: "Pending",
            on: [
              CHANGE: [
                target: ".Pending",
                actions: "assign_value"
              ]
            ],
            states: [
              Pending: [
                invoke: [
                  task: "validate_field",
                  done: "Valid"
                ],
                on: [
                  REPORT_INVALID: [
                    target: "Invalid",
                    actions: "assign_error"
                  ]
                ]
              ],
              Valid: [],
              Invalid: []
            ]
          ]
        ]
      ]
    ],
    Disabled: [
      on: [
        ENABLE: "Active"
      ]
    ]
  ]
end
```

#### Proposed macro syntax

```elixir
# defmodule FormInput do
# use Protean
ast =
  quote do
    machine do
      initial("Active")
      context(%{value: "", error: nil})

      states do
        "Active" ->
          type(:parallel)
          on("DISABLE", "Disabled")

          states do
            "Focus" ->
              initial("Unfocused")

              states do
                "Focused" ->
                  on("BLUR", "Unfocused")

                "Unfocused" ->
                  on("FOCUS", "Focused")
              end

            "Validation" ->
              initial("Pending")
              on({"CHANGE", _val}, ".Pending", actions: :assign_value)

              states do
                "Pending" ->
                  invoke(task: :validate_field, done: "Valid")
                  on({"REPORT_INVALID", _err}, "Invalid", actions: :assign_error)

                  "Valid"

                  "Invalid"
              end
          end

        "Disabled" ->
          on("ENABLE", "Active")
      end
    end
  end
```

This is about 20 lines shorter and `mix format` has no issues with it except for wanting to add parens around the calls. (That's pretty easily fixed using [`locals_without_parens`](https://hexdocs.pm/mix/main/Mix.Tasks.Format.html#module-importing-dependencies-configuration) which we can export.) There's also (imo) much better visual differentiation between the configuration language (`initial`, `states`, `on`, etc.) and the actual states (strings).

Another thing that this opens up is the potential to match on non-string events. We could actually do away with the `Protean.event` type entirely and let events be completely arbitrary things that you can match on using match syntax.

```elixir
quote do
  machine do
    initial("Init")

    states do
      "Init" ->
        on(%Events.Save{}, actions: :save)
        on(%Events.Other{}, "Other State")
        on({%Events.Whatever{}, _something}, "Whatever")
    end
  end
end
```

This would make Protean almost immediately compatible with any existing PubSub/event system you already have. For example, here's how you could match on the user update example from the `Phoenix.PubSub` [docs](https://hexdocs.pm/phoenix_pubsub/Phoenix.PubSub.html).

```elixir
quote do
  on({:user_update, _user}, actions: :assign_updates)
end
```

I was considering this entire "event coercion" system/callback so that you could transform events from other sources into something that Protean can understand i.e. `{"event", payload}`, but this makes that unnecessary since you could just match on anything.

Of course, now the machine definition macro is getting even _more_ complex because we'll need to generate some kind of matcher function attached to each transition, but that might not actually be too bad.

```elixir
defmodule Match do
  defmacro make_matcher(pattern) do
    quote do
      fn expr -> match?(unquote(pattern), expr) end
    end
  end
end
```

```elixir
require Match
quote(do: Match.make_matcher(%{x: 1, y: _})) |> Macro.expand_once(__ENV__) |> Macro.to_string()
```

```elixir
m = Match.make_matcher(%{x: 1, y: _})
m.(%{x: 1, y: 5})
```

Any nodes that accept keyword lists should be able to have them provided as a block. (Note: I'll need to move away from `when` even though I think it reads really well, but it's parsed as an operator and not a regular call so it messes up the AST in the block form).

```elixir
quote do
  on(%Events.SomeEvent{type: :foo}, "New State", guard: :some_guard?, actions: [:some_action])
  # equivalent to
  on(%Events.SomeEvent{type: :foo},
    target: "New State",
    guard: :some_guard?,
    actions: [:some_action]
  )

  # equivalent to
  on %Events.SomeEvent{type: :foo} do
    target("New State")
    guard(:some_guard?)
    actions([:some_action])
  end

  # also will need to handle:
  on(%Events.SomeEvent{type: :foo}, do: target("New State"))
end
```

```elixir
# Data definition for the syntax? defined sort of like a BNF grammar
#
# Basic idea here is:
#   - keys correspond to a call
#   - value represents the arity of the call and how to name the args
#   - attrs represent the attributes the call can receive either as kwargs or in a block
#   - alias represents an alternative name for the call
#   - attrs can appear more than once
#   - 
# 

grammar = [
  root: [attrs: [:type, :initial, :context, :on, :states]],
  type: :value,
  initial: :value,
  context: :value,
  on: [
    value: [{:pattern}, {:pattern, :target}],
    attrs: [:target, :guard, :actions]
  ],
  states: [attrs: [:state]],
  state: [
    alias: :->,
    value: {:name},
    attrs: [:type, :initial, :context, :on, :states, :invoke]
  ],
  invoke: [attrs: [:proc, :task, :stream, :done, :error, :guard]],
  proc: :value,
  task: :value,
  stream: :value,
  done: [from: :transition],
  error: [from: :transition],
  transition: [
    value: [{}, {:target}],
    attrs: [:target, :guard, :actions]
  ]
]
```

Possible alternative syntax is to get rid of `states` in favor of `state`, removes one extra level of nesting and additional syntax. However, it has the same scannability issue. The nice thing about the `states` syntax is that the use of `->` introduces a double-set of indentation, so it's really easy to track visually what is a part of what and when the `states` block ends.

```elixir
# defmodule FormInput do
# use Protean
ast =
  quote do
    machine do
      initial("Active")
      context(%{value: "", error: nil})

      state "Active" do
        type(:parallel)
        on("DISABLE", "Disabled")

        state "Focus" do
          initial("Unfocused")

          state "Focused" do
            on("BLUR", "Unfocused")
          end

          state "Unfocused" do
            on("FOCUS", "Focused")
          end
        end

        state "Validation" do
          initial("Pending")
          on({"CHANGE", _val}, ".Pending", actions: :assign_value)

          state "Pending" do
            invoke(task: :validate_field, done: "Valid")
            on({"REPORT_INVALID", _err}, "Invalid", actions: :assign_error)
          end

          state("Valid")
          state("Invalid")
        end
      end

      state "Disabled" do
        on("ENABLE", "Active")
      end
    end
  end
```

## New Syntax

This is a sketch of what I think the new syntax/API should be.

Main changes:

1. Move away from `{"string", data}` events to generic pattern matching on any term.
2. `@machine` -> `defmachine` macro
3. Move away from `Protean.send_event` etc. to `Protean.call` (sync), `Protean.send` (async), `Protean.send_after` etc. since we're now sending any term as an event. But machines will be fully compatible with the usual `send`/etc. and should be able to slot into any context that expects a GenServer-like thing. (Should look to `:gen_statem` for inspiration here.)
4. Maybe: Move to making the module that calls `use Protean` a GenServer directly (instead of "delegating" to `Protean.Interpreter.Server`). This would give us the ability to allow users to override `handle_info` and friends to potentially bypass certain messages or provide special handling.

```elixir
defmodule MediaPlayer do
  @moduledoc """
  A statechart modeling media playback of a profile to multiple connected users.
  """

  use Protean
  alias Protean.Action

  alias LiveBeats.{Accounts, MediaLibrary}
  alias LiveBeats.Accounts.{User}
  alias LiveBeats.MediaLibrary.{Profile, Song, Events}

  @pubsub LiveBeats.PubSub
  @idle_timeout_seconds 120

  @type context :: %{
    profile: Profile.t(),
    connected_user_ids: MapSet.t(User.t()),
    song: Song.t() | nil,
    played_at: DateTime.t() | nil,
    paused_at: DateTime.t() | nil
  }

  defmachine [
    initial: "Idle",
    context: %{
      profile: nil,
      song: nil,
      connected_user_ids: MapSet.new(),
      played_at: nil,
      paused_at: nil
    },
    on: [
      {%Events.UserConnected{}, actions: [:add_user]},
      {%Events.UserDisconnected{}, actions: [:remove_user]},
    ],
    states: [
      {
        "Idle",
        always: [
          target: "Active",
          guard: :has_users?
        ],
        after: [
          delay: @idle_timeout_seconds * 1000,
          target: "Timeout"
        ]
      },
      {
        "Active",
        initial: "Stopped",
        always: [
          target: "Idle",
          guard: [not: :has_users?]
        ],
        states: [
          {
            "Stopped",
            entry: [:clear_song, :broadcast_song_status],
            on: [
              {%Events.Play{}, target: "Playing"},
              {%Events.PlayPause{}, target: "Playing"}
            ]
          },
          {
            "Playing",
            invoke: [
              proc: :autoplay
            ],
            entry: [:set_song_playing, :broadcast_song_status],
            on: [
              {%Events.Pause{}, target: "Paused"},
              {%Events.PlayPause{}, target: "Paused"},
              {%Events.Stop{}, target: "Stopped"}
            ]
          },
          {
            "Paused",
            entry: [:set_song_paused, :broadcast_song_status],
            on: [
              {%Events.Play{}, target: "Playing"},
              {%Events.PlayPause{}, target: "Playing"},
              {%Events.Stop{}, target: "Stopped"}
            ]
          }    
        ]
      },
      {
        "Timeout",
        type: :final
      }
    ]
  ]

  @doc """
  Start a linked `MediaPlayer`.
  
  Options:

    * `:user_id` (required) - the ID of the first connected user
    * Any other opts that a Protean machine can accept

  """
  def start_link(opts \\ []) do
    {user_id, opts} = Keyword.pop!(opts, :user_id)

    context =
      opts
      |> Keyword.get(:context, %{})
      |> Map.put(connected_user_ids: MapSet.new([user_id]))

    opts
    |> Keyword.merge(context: context)
    |> super()
  end

  @impl true
  def invoke(:autoplay, state, _) do
    autoplay_context =
      state.context
      |> Map.take([:profile, :song])
      |> Map.put(:played_at, DateTime.utc_now())
    
    {MediaPlayer.Autoplay, context: autoplay_context}
  end

  @impl true
  def guard(:has_users?, state, _) do
    !Enum.empty?(state.context.connected_user_ids)
  end

  @impl true
  def action(:add_user, state, %Events.UserConnected{user: user}) do
    %{song: song} = state.context

    state
    |> current_song_event()
    |> broadcast!(user.id)

    state
    |> Action.assign_in([:connected_user_ids], &MapSet.put(&1, user.id))
  end

  def action(:remove_user, state, %Events.UserDisconnected{user: user}) do
    state
    |> Action.assign_in([:connected_user_ids], &MapSet.delete(&1, user.id))
  end

  def action(:clear_song, state, _) do
    state
    |> Action.assign(:song, nil)
    |> Action.assign(:played_at, nil)
    |> Action.assign(:paused_at, nil)
  end

  def action(:broadcast_song_status, state, _) do
    %{connected_user_ids: ids} = state.context
    
    state
    |> current_song_event()
    |> broadcast_to_all!(ids)

    state
  end

  def action(:set_song_paused, state, %{song: song}) do
    state
    |> set_song_paused(song)
  end

  def action(:set_song_paused, %{context: %{song: song}}, %Events.) do
    state
    |> Action.assign(:paused_at, DateTime.truncate(DateTime.utc_now(), :second))
  end

  def action(:set_song_playing, state, %{song: song}) do
    state
    |> set_song_playing(song)
  end

  def action(:clear_timestamps, state, _) do
    state
    |> Action.assign(:played_at, nil)
    |> Action.assign(:paused_at, nil)
  end

  defp set_song_paused(%{context: %{song: song}} = state, song) do
    state
    |> Action.assign(:paused_at, DateTime.truncate(DateTime.utc_now(), :second))
  end

  defp set_song_paused(state, _song), do: state

  defp set_song_playing(%{context: %{song: song}} = state, song) do
    %{paused_at: paused_at, played_at: played_at} = state.context

    played_at =
      if paused_at do
        elapsed = DateTime.diff(paused_at, played_at, :second)
        DateTime.add(DateTime.utc_now(), -elapsed)
      else
        DateTime.utc_now()
      end

    state
    |> Action.assign(:played_at, DateTime.truncate(played_at, :second))
    |> Action.assign(:paused_at, nil)
  end

  defp set_song_playing(state, song) do
    state
    |> Action.assign(:song, song)
    |> Action.assign(:played_at, DateTime.truncate(DateTime.utc_now(), :second))
    |> Action.assign(:paused_at, nil)
  end
  
  defp elapsed_playback(state) do
    %{played_at: played_at, paused_at: paused_at} = state.context

    cond do
      Protean.matches?(state, "Playing") ->
        start_seconds = played_at |> DateTime.to_unix()
        System.os_time(:second) - start_seconds

      Protean.matches?(state, "Paused") ->
        DateTime.diff(paused_at, played_at, :second)

      Protean.matches?(state, "Stopped") ->
        0
    end
  end
  
  defp current_song_event(state) do
    %{song: song} = state.context
    
    cond do
      Protean.matches?(state, "Playing") ->
        %Events.Play{song: song, elapsed: elapsed_playback(state)}

      Protean.matches?(state, "Paused") ->
        %Events.Pause{song: song}

      Protean.matches?(state, "Stopped") ->
        %Events.Stop{song: song}
    end
  end

  defp broadcast_to_all!(msg, ids), do: Enum.each(ids, &broadcast!(msg, &1))

  defp broadcast!(msg, user_id) when is_integer(user_id) do
    Phoenix.PubSub.broadcast!(@pubsub, "profile:#{user_id}", {__MODULE__, msg})
  end
end

```

```elixir
defmodule MediaPlayer.AutoplayNext do
  @moduledoc """
  Helper statechart used to check whether the song is ending and communicate back to
  the parent.
  """

  use Protean
  alias Protean.Action

  alias LiveBeats.MediaLibrary
  alias LiveBeats.MediaLibrary.{Profile, Song, Events}

  @auto_next_threshold_seconds 5

  @type context :: %{
          profile: Profile.t(),
          song: Song.t(),
          played_at: DateTime.t()
        }

  defmachine(
    initial: "AutoplayNext",
    states: [
      {
        "AutoplayNext",
        always: [
          target: "SongEnding",
          guard: :song_ending?
        ],
        after: [
          delay: @auto_next_threshold_seconds * 1000,
          target: "AutoplayNext"
        ]
      },
      {
        "SongEnding",
        type: :final, entry: [:send_next_to_parent]
      }
    ]
  )

  @impl true
  def guard(:song_ending?, state, _) do
    %{song: song, played_at: ts} = state.context
    elapsed = DateTime.diff(DateTime.utc_now(), ts, :second)

    elapsed >= song.duration - @auto_next_threshold_seconds
  end

  @impl true
  def action(:send_next_to_parent, state, _) do
    %{profile: profile, song: song} = state.context

    next_event =
      case MediaLibrary.get_next_song(song, profile) do
        nil -> %Events.Stop{}
        song -> %Events.Play{song: song}
      end

    state
    |> Action.send(next_event, to: :parent)
  end
end
```

```elixir
{:ok, pid} = MediaPlayer.start_link(user_id: 10)

:ok = Protean.send(pid, %MediaLibrary.Events.Play{song: song})
%Protean.State{} = Protean.call(pid, %MediaLibrary.Events.Pause{song: song})
```

Random thought: It should be possible to stick a machine as a producer/consumer in a GenStage pipeline, where it runs events through the machine and yields its state.
