<!-- livebook:{"persist_outputs":true} -->

# Example: Debounce & Throttle

```elixir
Mix.install([
  {:protean, git: "https://github.com/zachallaun/protean.git"}
])

Supervisor.start_link([Protean.Supervisor], strategy: :one_for_one)
```

<!-- livebook:{"output":true} -->

```
{:ok, #PID<0.211.0>}
```

## Introduction

Debounce and throttle are techniques used to control streams of events, often in the assigns of user interfaces. Both are used to limit the flow of events.

* **Debounce** limits events by buffering incoming events and only emitting the latest one after a certain amount of time has passed with no new events. Consider a real-time search field, for instance: the user starts typing, and each character emits a `change`. Instead of starting the search, canceling, and starting over on every keypress, you could _debounce_ the events, only emitting a change (and triggering the search) after the user has stopped typing for a certain amount of time.
* **Throttle** emits the first event immediately, but then waits a certain amount of time before emitting another. This turns a potentially rapid stream of events into a constant interval (so long as events are coming faster than the timeout period).

## Debounce

```elixir
defmodule Examples.Debounce do
  use Protean

  @type assigns :: %{
          timeout: non_neg_integer()
        }

  @machine [
    initial: "waiting",
    assigns: [
      timeout: 1_000
    ],
    states: [
      waiting: [
        on: [
          {match(_), target: "debouncing"}
        ]
      ],
      debouncing: [
        after: [
          delay: :timeout,
          actions: [:reply_with_latest_event],
          target: "waiting"
        ],
        on: [
          {match(_), target: "debouncing", internal: false}
        ]
      ]
    ]
  ]

  @impl Protean
  def delay(:timeout, %{assigns: %{timeout: t}}, _), do: t

  @impl true
  def handle_action(:reply_with_latest_event, state, event) do
    {:reply, event, state}
  end
end
```

<!-- livebook:{"output":true} -->

```
{:module, Examples.Debounce, <<70, 79, 82, 49, 0, 0, 39, ...>>, {:handle_action, 3}}
```

Our debounce machine relies on delayed- and self-transitions.

We start in a `waiting` state, awaiting any event. When the first event comes in, we switch to a `debouncing` state. `debouncing` will define a delayed transition based on whatever timeout value is set in the machine assigns. If the delay goes by, we emit the latest event with a `:reply` tuple.

However, if any events come in while we're `debouncing`, we do an external self-transition, resetting the timeout:

<!-- livebook:{"force_markdown":true} -->

```elixir
debouncing: [
  # After the delay specified by the `delay(:timeout, state, event)`
  # callback, reply with the last event and transition back to waiting.
  after: [
    delay: :timeout,
    actions: :reply_last,
    target: "waiting"
  ],
  on: [
    # Transitioning to yourself is an internal transition by default,
    # which means that entry and exit actions aren't re-executed. Setting
    # internal: false makes it an external transition, so it's as if we
    # are leaving the debouncing state, which cancels the timer, and then
    # re-entering it, starting it again.
    {match(_), target: "debouncing", actions: :set_last, internal: false}
  ]
]
```

Let's spin one up and give it a whirl.

```elixir
{:ok, debounce} = Examples.Debounce.start_link()
Protean.subscribe(debounce, :replies)
```

<!-- livebook:{"output":true} -->

```
#Reference<0.2612791341.2823290881.154519>
```

Our debouncer is emitting debounced events as answers, so we've subscribed only to them (as opposed to every state transition). This will put messages in our mainbox.

Now, let's send some events. We expect our debounce machine to send us one on our subscription 1000ms after the last one we send.

```elixir
Enum.each(1..5, fn _ ->
  Protean.send(debounce, DateTime.utc_now())
  :timer.sleep(250)
end)

receive do
  {:state, _, {_, [event]}} ->
    [event: event, now: DateTime.utc_now()]
after
  5_000 -> IO.inspect(:nothing)
end
```

<!-- livebook:{"output":true} -->

```
[event: ~U[2022-08-08 02:39:11.807941Z], now: ~U[2022-08-08 02:39:12.809021Z]]
```

By default, our debouncer is waiting for 1,000ms since the last event before emitting it, but we can control that behavior by providing a different `:timeout` in the machine's assigns.

```elixir
{:ok, debounce_500ms} = Examples.Debounce.start_link(assigns: %{timeout: 500})
Protean.subscribe(debounce_500ms, :replies)
```

<!-- livebook:{"output":true} -->

```
#Reference<0.2612791341.2823290881.154568>
```

```elixir
# Same block as before, except using pid_500ms and events every 250ms
Enum.each(1..5, fn _ ->
  Protean.send(debounce_500ms, DateTime.utc_now())
  :timer.sleep(250)
end)

receive do
  {:state, _, {_, [event]}} ->
    [event: event, now: DateTime.utc_now()]
after
  5_000 -> IO.inspect(:nothing)
end
```

<!-- livebook:{"output":true} -->

```
[event: ~U[2022-08-08 02:39:13.831907Z], now: ~U[2022-08-08 02:39:14.333010Z]]
```

```elixir
Process.info(self(), :messages)
```

<!-- livebook:{"output":true} -->

```
{:messages, []}
```

## Throttle

Throttle works a bit differently, emitting a constant stream of events, but no more frequently than specified by `:timeout`. This means we should receive an event immediately, and then the latest event every `:timeout` milliseconds.

```elixir
defmodule Examples.Throttle do
  use Protean
  alias Protean.Action

  @type assigns :: %{
          timeout: non_neg_integer(),
          last_event: term()
        }

  @machine [
    initial: "waiting",
    assigns: [
      timeout: 1_000,
      last_event: nil
    ],
    on: [
      {match(_), actions: [:set_last]}
    ],
    states: [
      waiting: [
        always: [
          target: "throttling",
          guard: :has_event?
        ]
      ],
      throttling: [
        entry: [:reply_and_clear_last],
        after: [
          [
            delay: :timeout,
            guard: :has_event?,
            target: "throttling",
            internal: false
          ],
          [
            delay: :timeout,
            guard: [not: :has_event?],
            target: "throttling",
            internal: true
          ]
        ]
      ]
    ]
  ]

  @impl Protean
  def delay(:timeout, %{assigns: %{timeout: t}}, _), do: t

  @impl Protean
  def guard(:has_event?, %{assigns: %{last_event: nil}}, _), do: false
  def guard(:has_event?, _, _), do: true

  @impl Protean
  def handle_action(:set_last, state, event) do
    Action.assign(state, :last_event, event)
  end

  def handle_action(:reply_last, state, _) do
    {:reply, state.assigns.last_event, state}
  end

  def handle_action(:reply_and_clear_last, state, _) do
    {:reply, state.assigns.last_event, Action.assign(state, :last_event, nil)}
  end
end
```

<!-- livebook:{"output":true} -->

```
{:module, Examples.Throttle, <<70, 79, 82, 49, 0, 0, 49, ...>>, {:handle_action, 3}}
```

```elixir
{:ok, pid} = Examples.Throttle.start_link()
ref = Protean.subscribe(pid, :replies)
```

<!-- livebook:{"output":true} -->

```
#Reference<0.2612791341.2823290881.155165>
```

```elixir
Task.async(fn ->
  Enum.each(1..5, fn _ ->
    Protean.send(pid, DateTime.utc_now())
    :timer.sleep(500)
  end)
end)

Enum.each(1..4, fn _ ->
  receive do
    {:state, _, {_state, message}} ->
      time = DateTime.utc_now()
      IO.inspect({message, at: time}, label: "received")
  after
    1_500 -> :nothing
  end
end)
```

<!-- livebook:{"output":true} -->

```
received: {[~U[2022-08-08 02:39:28.847154Z]], [at: ~U[2022-08-08 02:39:28.847295Z]]}
received: {[~U[2022-08-08 02:39:29.347916Z]], [at: ~U[2022-08-08 02:39:29.848035Z]]}
received: {[~U[2022-08-08 02:39:30.349909Z]], [at: ~U[2022-08-08 02:39:30.849084Z]]}
received: {[~U[2022-08-08 02:39:30.850867Z]], [at: ~U[2022-08-08 02:39:31.850103Z]]}
```

<!-- livebook:{"output":true} -->

```
:ok
```

```elixir
Process.info(self(), :messages)
```

<!-- livebook:{"output":true} -->

```
{:messages,
 [
   {#Reference<0.2612791341.2823356417.155170>, :ok},
   {:DOWN, #Reference<0.2612791341.2823356417.155170>, :process, #PID<0.242.0>, :normal}
 ]}
```
